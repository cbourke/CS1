%!TEX root = ComputerScienceOne.tex

%%Chapter: Java Basics

The Java programming language was developed in the early 1990s at
Sun Microsystems by James Gosling, Mike Sheridan, and Patrick 
Naughton.  Its original intention was to enable cable box sets to
be more interactive.  By the mid-90s, Java was retargeted toward 
the \gls{wwwLabel}.  The first public release came on May 23, 1995
with the first \gls{jdkLabel}, Java 1.0 on January 23rd, 1996.  A 
new, updated release has come about every other year.  As of 2014, 
Java 8 is the current stable version. 

Today, Java is one of the most popular programming languages, consistently
ranked as one of the top 2 languages (see \url{http://www.tiobe.com}).  It
is now owned and maintained by Oracle, but there are many open
source tools, compilers and runtime environments available.  Java is
used in everything from mobile devices (Android) and desktop applications 
to enterprise-level servers.  

From its inception, Java was designed with 5 basic principles:
\begin{enumerate}
  \item Simple, Object-oriented, familiar
  \item Robust and secure
  \item Architecture-neutral and portable
  \item High performance
  \item Interpreted, threaded and dynamic
\end{enumerate}

Java offers many key features that have made it popular.  It is unique
in that it is not entirely compiled nor interpreted.  Instead, Java source
code is compiled into an intermediate form, called Java bytecode.  
This bytecode is not directly runnable on a processor.  Instead, a
\gls{jvmLabel}, an application that was written and compiled a 
particular processor, interprets the bytecode and runs the application.
This added layer of abstraction means that Java source code can
be written once (and compiled once) and then run anywhere on 
any device that has a \gls{jvmLabel}.  The added layer of abstraction
makes development easier, but does come at a cost in performance.
However, the most recent \glspl{jvmLabel} have offered performance
that is comparable to native machine code in many applications.

Another key feature is that Java has its own automated \gls{garbage 
collection}.  Some languages require manual memory management, 
meaning that requesting, managing, and freeing up memory is part
of the code that you write as a developer.  Failure to handle memory
management properly can lead to wasted resources (memory leaks), 
poor or unstable performance, and even more serious security issues 
(buffer overflows).  In Java, there is no manual memory management.
The \gls{jvmLabel} handles the allocation and clean up of memory automatically.

In following with the five design principles, Java is similar in syntax to
C (called ``C-style syntax'').  Executable statements are terminated
by semicolons, code blocks are defined by opening/closing curly brackets, 
etc.  Java is also fundamentally an \gls{oopLabel} language.
With the exception of a few primitive types, in Java, everything is
an object or belongs to an object.

\section{Getting Started: Hello World}

The hallmark of the introduction of programming languages is the \emph{Hello World!}
program.  It consists of a simple program whose only purpose is to print out the message
``Hello World!'' to the user in some manner.  The simplicity of the program allows the
focus to be on the basic syntax of the language.  It is also typically used to ensure that 
your development environment, compiler, runtime environment, etc. are functioning 
properly with a minimal example.  A basic Hello World! program in Java can be found in 
Code Sample \ref{code:java:helloWorldProgram}.

\begin{listing}
\begin{minted}{java}
package unl.cse;  //package declaration

//imports would go here

/**
 * A basic hello  world program in Java
 */
public class HelloWorld {

  //static main method
  public static void main(String args[]) {
    System.out.println("Hello World!");
  }

}
\end{minted}
\caption{Hello World Program in Java}
\label{code:java:helloWorldProgram}
\end{listing}

We will not focus on any particular development environment, code editor, or any 
particular operating system, compiler, or ancillary standards in our presentation.  
However, as a first step, you should be able to write, compile, and run the above 
program on the environment you intend to use for the rest of this book.  This may 
require that you download and install a \gls{jdkLabel} and \gls{ideLabel}.  Eclipse
(\url{http://eclipse.org/}) is the industry standard, though IntelliJ (\url{https://www.jetbrains.com/idea/})
and NetBeans (\url{https://netbeans.org/}) are also popular among many others.

\section{Basic Elements}

Using the Hello World! program as a starting point, we will now examine the basic
elements of the Java language.

\subsection{Basic Syntax Rules}

Java's syntax is adopted from C, referred to as ``C-style syntax.''  These elements 
include the following.
\begin{itemize}
  \item Java is a statically typed language so variables must be declared along with
  	their types before using them.
  \item Strings are delimited with double quotes.  Single characters, including
  	special escaped characters are delimited by single quotes; \mintinline{java}{"this is a string"}, 
	and these are characters: \mintinline{java}{'A'}, \mintinline{java}{'4'}, \mintinline{java}{'$'} and
	\mintinline{java}{'\n'}
  \item In addition, Java uses Unicode (UTF-16 encoding) to represent characters.
  	This is fully back-compatible with \gls{asciiLabel}, but also allows you to 
	specify Unicode characters using special escape sequences and hexadecimal
	encodings.  For example, 
	\mintinline{java}{'\u4FFA'} represents a Japanese character:
	\begin{center}
	\includegraphics[scale=0.20]{images/ore.png}
	\end{center}
	The string \mintinline{java}{"\u4FFA\u306F \u6700\u9AD8\u3060\u305C\uFF01"}
	represents the phrase 
	\begin{center}
	\includegraphics[scale=1.0]{images/japanesePhrase.png}
	\end{center}
  \item Executable statements are terminated by a semicolon, \mintinline{java}{;}
  \item Code blocks are defined by using opening and closing curly brackets, 
  	\mintinline{java}{{ ... }}.  Moreover, code blocks can be \emph{nested}: code
	blocks can be defined within other code blocks.  
  \item Variables are \glslink{scope}{scoped} to the code block in which they are declared
  	and are only valid within that code block.
  \item In general, whitespace between coding elements is ignored.
\end{itemize}

Though not a syntactic requirement, the proper use of whitespace is important for
good, readable code.  Code inside code blocks is indented at the same indentation.
Nested code blocks are indented further.  Think of a typical table of contents or
the outline of a formal paper or essay.  Sections and subsections or points and 
points all follow proper indentation with elements at the same level at the same
indentation.  This convention is used to organize code and make it more readable.

\subsection{Program Structure}

\subsubsection{Classes}

In Java, everything is a \emph{class} or belongs to a class.  A class is an 
extensible program or blueprint for creating objects.  Objects are an integral
part of \gls{oopLabel} that we'll explore later.  However, to start out our
programs will be simple enough that the can be contained in a single class.

To declare a class, you use the following syntax.

\mintinline{java}{public class HelloWorld { ... }}

where the contents of the class are placed between the opening/closing curly
brackets.  In addition, a class must be placed in a Java source file with the same
name.  In our previous example, the class must be in a file named 
\mintinline{java}{HelloWorld.java}.  

When naming classes, the most commonly accepted naming convention 
is to use uppercase camel casing (also called PascalCase) in which each
word in the name is capitalized including the first.  Examples:
\mintinline{java}{Employee}, \mintinline{java}{SavingsAccount}, 
\mintinline{java}{ImageFile}, etc.  Class names (as well as their source file
names) are case sensitive.

\subsubsection{Packages}

Java code is organized into modules called \emph{packages}.  Packages
are essentially directories (or folders) which follow a directory tree 
structure which allows subdirectories and separate directories at the same
level.  It all starts at the \emph{root} directory called the ``default'' package.

Within a source file, we declare which package the file belongs to using
the keyword \mintinline{java}{package} followed by a ``fully qualified
package declaration'' which is essentially just the names of the directories
that the file is located in, separated by a period.  The declaration is terminated
by a semicolon.  For example, the package declaration, 

\mintinline{java}{package unl.cse;}

would indicate that the file belongs in the directory \mintinline{java}{cse}
which is a subdirectory of the directory \mintinline{java}{unl}.  The
absence of a package declaration will mean that the file is associated
with the default directory.  

Packages allow you to organize source files and code functionality.  
Mathematics related classes can be placed in one package while 
image related classes can be placed in another, etc.  It also provides
separate name spaces for classes.  There could be 3 or 4 different
classes named \mintinline{java}{List} for example.  They could not
be located in the same directory, however: if you wanted to use one
which one would you be referring to?  By separating them into 
packages, they can all exist without conflict.  When we want to
use a particular one, we \emph{import} that class with its fully
qualified package name.

\subsubsection{Imports}

An \mintinline{java}{import} statement essentially ``brings in'' another
class so that its methods and functionality can be used.  For example, 
there is a class named \mintinline{java}{Scanner} (located in the
package \mintinline{java}{java.util}) that makes it easy to read input
from the standard input.  To include it in our program so that we can
use its functionality, we would need\footnote{Strictly, speaking you
can still use it without importing it, but you'd need to use a fully
qualified path name at declaration/instantiation.} to import it: 

\mintinline{java}{import java.util.Scanner;}

Classes in the package \mintinline{java}{java.lang} (such as 
\mintinline{java}{String} and \mintinline{java}{Math}) are 
considered standard and are imported by default without an 
explicit \mintinline{java}{import} statement.  

You may see some code that uses a \emph{wildcard} like
\mintinline{java}{import java.util.*;} which ends up importing
every class in that package.  This is generally considered bad
practice.  In general, code should be intentional and specific, 
importing every class even if they are not used goes against
this principle. 

When naming packages, you must follow the general naming 
rules for identifiers (see below).  Package names cannot begin
with a number, no whitespace, etc.  Moreover, the general
convention for package names is to use lowercase underscore
casing, \mintinline{java}{here_is_an_example}.  Moreover, 
packages and subpackages follow the same convention as
directories: the top most directory is the most general and
subdirectories are more and more specific.  

In many of our examples we'll use \mintinline{java}{unl.cse} 
(UNL, University of Nebraska--Lincoln; CSE, Department of
Computer Science \& Engineering) which illustrates this 
general-to-specific organization.

\subsection{The \mintinline{java}{main} Method}

Every executable program has to have a beginning: a point at which the
program starts to execute.  In Java, a class may contain many variables 
and methods, but a class is only \emph{executable} if it contains a 
\mintinline{java}{main} method.  When a Java class is compiled and
the JVM is started, the JVM loads the class into memory and 
starts executing code contained in the \mintinline{java}{main} method.

In addition, our \mintinline{java}{main} method takes an \emph{array}
of \mintinline{java}{String} types which which serve to communicate
any command line arguments provided to the program (review Section
\ref{subsection:commandLineInput} for details).  The array, 
\mintinline{java}{args} stores the arguments as strings.  The number
of arguments provided can be determined using the \mintinline{java}{length}
property of the array.  Specifically, \mintinline{java}{args.length} is
an integer indicating how many arguments were provided.  This does 
\emph{not} include the name of the program (class) itself as that is
already be known to the programmer.

To access any one argument, it will be necessary to
\emph{index}.  The index for the first argument is zero, thus the
first argument is \mintinline{java}{args[0]}, the second is \mintinline{java}{args[1]}, etc.
The last one would be at \mintinline{java}{args[args.length-1]}.

If a user is expected to provide numbers as input, they'll need to
be converted as the \mintinline{java}{args} array are only \mintinline{java}{String}
types.  To convert the arguments you can use parsing methods provided by the 
\mintinline{java}{Integer} and \mintinline{java}{Double} classes.
An example:

\begin{minted}{java}
//converts the "first" command line argument to an integer
int x = Integer.parseInt(args[0]);  
//converts the "third" command line argument to a double:
double y = Double.parseDouble(args[1]);
\end{minted}

\subsection{Comments}

Comments can be written in a Java program either as a single line using
two forward slashes, \mintinline{java}{//comment} or as a multiline comment using
a combination of forward slash and asterisk: \mintinline{java}{/* comment */}.  
With a single line comment, everything on the line \emph{after} the forward
slashes is ignored.  With a multiline comment, everything in between the forward
slash/asterisk is ignored.  Comments are ultimately ignored by the compiler so
the amount of comments do not have an effect on the final executable code.
Consider the following example.

\begin{minted}{java}
//this is a single line comment
int x;  //this is also a single line comment, but after some code

/*
  This is a comment that can 
  span multiple lines to format the comment
  message more clearly
*/
double y;
\end{minted}

Most code editors and \glspl{ideLabel} will present comments in a special color or
font to distinguish them from the rest of the code (just as our example above does).
Failure to close a multiline comment will likely result in a compiler error but with
color-coded comments its easy to see the mistake visually.

Another common comment style convention is the Javadoc (Java Documentation)
style of comments.  Javadoc style comments are multiline comments that begin
with \mintinline{java}{/**} (that is, two asterisks).  The Javadoc framework allows you
to \emph{markup} your comments with tags and links so that documentation can
be automatically generated and published.  We will sometimes use this style, but
we will not cover the details.  For documentation, see Oracle's website, \url{http://www.oracle.com/}.

\section{Variables}

Java has 8 built-in \gls{primitive} types supporting numbers (integers 
and floating-point numbers), Booleans, and characters.  Table \ref{table:javaPrimitives}
contains a complete description of these types.  Each of these primitive
types also has a corresponding \emph{wrapper} class defined in the 
\mintinline{java}{java.lang} package.  Wrapper classes provide \emph{object}
versions of each of these classes.  The object versions have many utility
methods that can be used in relation to their type.  For example, the
aforementioned \mintinline{java}{Integer.parseInt()} method is part of the 
\mintinline{java}{Integer} wrapper class.

\begin{table}
\centering
\begin{tabular}{l|l|l}
 Type & Description & Wrapper Class\\
\hline\hline
\mintinline{java}{byte} & 8-bit signed 2s complement integer & \mintinline{java}{Byte} \\
\mintinline{java}{short} & 16-bit signed 2s complement integer  & \mintinline{java}{Short} \\
\mintinline{java}{int} & 32-bit signed 2s complement integer & \mintinline{java}{Integer}  \\
\mintinline{java}{long} & 64-bit signed 2s complement integer  & \mintinline{java}{Long} \\
\mintinline{java}{float} & 32-bit IEEE 754 floating point number & \mintinline{java}{Float} \\
\mintinline{java}{double} & 64-bit floating point number & \mintinline{java}{Double}  \\
\mintinline{java}{boolean} & may be set to \mintinline{java}{true} or \mintinline{java}{false} & \mintinline{java}{Boolean} \\
\mintinline{java}{char} & 16-bit Unicode (UTF-16) character & \mintinline{java}{Character}  \\
\end{tabular}
\caption{Primitive types in Java}
\label{table:javaPrimitives}
\end{table}

The wrapper classes, however, are different.  These are objects, so when a reference is declared
for them, by default, that reference refers to \mintinline{java}{null}.  The keyword \mintinline{java}{null}
is used to indicate a special memory address that represents ``nothing''.  In fact, the
default value for \emph{any} object type is \mintinline{java}{null}.  Care must be taken
when mixing primitive types and their wrapper classes (see below) as \mintinline{java}{null}
references may result in a \mintinline{java}{NullPointerException}.  Finally, instances
of the wrapper classes are \gls{immutable}.  Once they are created, they cannot be changed.
References can be made to reference a different object, but the object's value cannot
be changed.  

\subsection{Declaration \& Assignment}

Java is a statically typed language meaning that all variables must be declared
before you can use them or refer to them.  In addition, when declaring a variable, 
you must specify both its type and its identifier.  For example:

\begin{minted}{c}
int numUnits;
double costPerUnit;
char firstInitial;
boolean isStudent;
\end{minted}

Each declaration specifies the variables type followed by the 
identifier and ending with a semicolon.  The identifier rules are 
fairly standard: a name can consist of lower and uppercase 
alphabetic characters, numbers, and underscores but may 
\emph{not} begin with a numeric character.  We adopt the 
modern camelCasing naming convention for variables in our 
code.

In general, variables \emph{must} be assigned a value before
you can ``read'' them (say printing them) or otherwise using them
in an expression.  You do not have to immediately assign a value
when you declare them (though it is good practice), but some value
must be assigned before they can be used or the compiler
will issue an error.\footnote{Instance variables, that is variables
declared as part of an object \emph{do} have default values.
For objects, the default is \mintinline{java}{null}, for all numeric t
ypes, zero is the default value.  For the \mintinline{java}{boolean} 
type, \mintinline{java}{false} is the default, and the default 
\mintinline{java}{char} value is \mintinline{text}{\0}, the 
null-terminating character (zero in the \gls{asciiLabel} table).}

The assignment operator is a single equal sign, \mintinline{java}{=} and is a right-to-left
assignment.  That is, the variable that we wish to assign the value to appears on the
left-hand-side while the value (literal, variable or expression) is on the right-hand-size.
Using our variables from before, we can assign them values:

\begin{minted}{java}
numUnits = 42;
costPerUnit = 32.79;
firstInitial = 'C';
isStudent = true;
\end{minted}

For brevity, Java allows you to declare a variable and immediately assign 
it a value on the same line.  So these two code blocks could have been 
more compactly written as:

\begin{minted}{c}
int numUnits = 42;
double costPerUnit = 32.79;
char firstInitial = 'C';
boolean isStudent = true;
\end{minted}

As another shorthand, we can declare multiple variables on the same line by delimiting
them with a comma.  However, they \emph{must} be of the same type.  We can also 
use an assignment with them. 

\begin{minted}{c}
int numOrders, numUnits = 42, numCustomers = 10, numItems;
double costPerUnit = 32.79, salesTaxRate;
\end{minted}

Another convenient keyword is \mintinline{java}{final}.  Though it has several uses, 
when applied to a variable declaration, it makes it a read-only variable.  After a
value has been assigned to a \mintinline{java}{final} variable, its value cannot
be changed.  

\begin{minted}{java}
final int secret = 42;
final double salesTaxRate = 0.075;
\end{minted}

Any attempt to reassign the values of \mintinline{java}{final} variables will result
in a compiler error.

\section{Operators}

Java supports the standard arithmetic operators for addition, subtraction, multiplication, and
division using \mintinline{java}{+}, \mintinline{java}{-}, \mintinline{java}{*}, and
\mintinline{java}{/} respectively.  Each of these operators is a binary operator that
acts on two operands which can either be literals or other variables and follow
the usually rules of arithmetic when it comes to order of precedence (multiplication 
and division before addition and subtraction).

\begin{minted}{java}
int a = 10, b = 20, c = 30, d;
d = a + 5;
d = a + b;
d = a - b;
d = a + b * c;
d = a * b;
d = a / b; //integer division and truncation!  See below

double x = 1.5, y = 3.4, z = 10.5, w;
w = x + 5.0;
w = x + y;
w = x - y;
w = x + y * z;
w = x * y;
w = x / y;

//you can do arithmetic with both types:
w = a + x;

//however you CANNOT assign a double to an integer:
d = b + y; //compilation error
//but you can do so with an explicit type cast:
d = (int) (b + y);  //though truncation occurs, d is 23
\end{minted}

In addition, you can \emph{mix} the wrapper classes with their primitive types.
You must be careful though.  The wrapper classes are object references which
can be \mintinline{java}{null}.  If a \mintinline{java}{null} reference is used
in an arithmetic expression, it will result in a \mintinline{java}{NullPointerException}
which can be caught and handled.  If not caught, it will end up being a fatal
error.  Some examples:

\begin{minted}{java}
int a = 10, c;
Integer b = 20;

//int and Integer can be mixed:
c = a + b;

double x = 3.14, z;
Double y = 2.71;
//double and Double can be mixed:
z = x + y;

//all types can be mixed:
double u = a + x + b + y;

//Be careful:
Integer d = null;
c = a + d; //NullPointerException
\end{minted}

This works because of a mechanism called \emph{autoboxing} (or \emph{autounboxing} in
this case).  The wrapper class is acting like a ``box'': its an object that stores
the value of a primitive type.  When it gets used in an arithmetic expression, it
gets ``unboxed'' and converted to a primitive type so that the arithmetic
operation is performed on compatible primitive types.  This is all done by the 
compiler and is completely transparent to us.  However, that is the reason that
we may get a \mintinline{java}{NullPointerExcpetion}.  Our code actually gets
converted from \mintinline{java}{c = a + d;} to \mintinline{java}{c = a +d.doubleValue();}.
The \mintinline{java}{doubleValue} method returns a \mintinline{java}{double} primitive
value.  However, if \mintinline{java}{d} is \mintinline{java}{null}, you can't call
a method on it; thus the \mintinline{java}{NullPointerException}.

Special care must be taken when dealing with \mintinline{java}{int} types.  
For all four operators, if both operands are integers, the result will be an
integer.  For addition, subtraction, and multiplication this isn't an issue, but
for division it means that when we divide, say \mintinline{java}{(10 / 20)}, the result
is not $0.5$ as expected.  The number 0.5 is a floating-point number.  As
such, the fractional part gets \gls{truncation}{truncated} (cut off and thrown out) leaving
only zero.  In the code above, \mintinline{java}{d = a / b;} the variable \mintinline{java}{d}
ends up getting the value zero because of this.

A solution to this problem is to use explicit \gls{type casting} to force at
least one of the operands in an integer division to become a \mintinline{java}{double}
type.  For example:

\begin{minted}{java}
int a = 10, b = 20;
double x;

x = (double) a / b; 
\end{minted}

Assigning a floating-point number to an integer is not allowed in
Java and attempting to do so will be treated as a compiler error.  This
is because Java does not support \emph{implicit} type casts.
However, you \emph{can} do so if you provide an \emph{explicit} type cast
as in the code above, 

\mintinline{java}{d = (int) (b + y);}

In this code, \mintinline{java}{b + y} is correctly computed as $20 + 3.4 = 23.4$, 
but the explicit type cast (down to an integer) results in truncation.  The $.4$ 
gets cutoff and \mintinline{java}{d} gets the value 23.

Assigning an \mintinline{java}{int} value to a \mintinline{java}{double} variable is
not a problem as the integer $2$ becomes the floating-point number $2.0$.

Java also supports the integer remainder operator using the \mintinline{java}{%} symbol.
This operator gives the remainder of the result of dividing two integers.  Examples:

\begin{minted}{java}
int x;

x = 10 % 5; //x is 0
x = 10 % 3; //x is 1
x = 29 % 5; //x is 4
\end{minted}

\section{Basic I/O}

Java provides several ways to perform input and output operations on the standard
input/output as part of the \mintinline{java}{System} class.  The \mintinline{java}{System}
class contains a standard output stream which can be accessed using \mintinline{java}{System.out}.
It also has a standard input stream which can be accessed using \mintinline{java}{System.in}.

For output, there are several methods that can be used but we'll focus on \mintinline{java}{println}
and \mintinline{java}{printf}.  The first is for printing strings on a single line.  The \mintinline{java}{ln}
at the end indicates that the method will insert an endline character, \mintinline{text}{\n} for you.
The second is a \mintinline{java}{printf}-style output method that takes placeholders like \mintinline{java}{%d} 
and \mintinline{java}{%f} (review Section \ref{subsection:printfStyleFormatting} for details).

The easiest way to read input is through the \mintinline{java}{Scanner} class.  You can create
a new instance of the scanner class and associate it with the standard input using the following
code.

\mintinline{java}{Scanner s = new Scanner(System.in);}

The variable \mintinline{java}{s} is now active and can be read from.  You can get specific
values from the \mintinline{java}{Scanner} by calling various methods such as \mintinline{java}{s.nextInt()}
to get an \mintinline{java}{int}, \mintinline{java}{s.nextDouble()} to get a \mintinline{java}{double}, etc.
When these methods are called, the program \emph{blocks} until the user enters her input
and presses the enter/return key.  The conversion to the type you requested is automatic.
A full example is depicted in Code Sample \ref{code:java:basicIO}.

\begin{listing}
\begin{minted}{java}
Scanner s = new Scanner(System.in);
int a;
System.out.println("Please enter a number: ");
a = s.nextInt();
System.out.printf("Great, you entered %d\n", a);
\end{minted}
\caption{Basic Input/Output in Java}
\label{code:java:basicIO}
\end{listing}

One potential problem with using \mintinline{java}{Scanner} is that the 
methods cannot force a user to enter good input.  In the example above,
if the user, instead of entering a number, entered \mintinline{java}{"Hello"}, 
the conversion to a number would fail.  This would result in a 
\mintinline{java}{InputMismatchException}.

\section{Examples}

\subsection{Converting Units}

Let's start with a simple task: let's write a program that will prompt 
the user to enter a temperature in degrees Fahrenheit and convert 
it to degrees Celsius using the formula
  $$C = (F - 32) \cdot \frac{5}{9}$$

We begin with the basic program outline which will include a package and
class declaration.  We'll also need
to read from the standard input, so we'll import the \mintinline{java}{Scanner}
class.  We'll want want our class to be executable, so we need to 
put a \mintinline{java}{main} method in our class.  Finally, we'll document
our program to indicate its purpose.


\begin{minted}{java}
package unl.cse;

import java.util.Scanner;

/**
 * This program converts Fahrenheit temperatures to 
 * Celsius
 */
public class TemperatureConverter {

  public static void main(String args[]) {

    //TODO: implement this

  }
}
\end{minted}

It is common for programmers to use a comment along with a 
\mintinline{java}{TODO} note to themselves as a reminder of things 
that they still need to do with the program.  

Let's first outline the basic steps that our program will go through:
\begin{enumerate}
  \item We'll first prompt the user for input, asking them for a temperature in Fahrenheit
  \item Next we'll read the user's input, likely into a floating-point number as degrees can be fractional
  \item Once we have the input, we can calculate the degrees Celsius by using the formula above
  \item Lastly, we will want to print the result to the user to inform them of the value
\end{enumerate}
Sometimes its helpful to write an outline of such a program directly in the code using
comments to provide a step-by-step process.  For example:

\begin{minted}{java}
package unl.cse;

import java.util.Scanner;

/**
 * This program converts Fahrenheit temperatures to 
 * Celsius
 */
public class TemperatureConverter {

  public static void main(String args[]) {

    //TODO: implement this
    //1. Prompt the user for input in Fahrenheit
    //2. Read the Fahrenheit value from the standard input
    //3. Compute the degrees Celsius
    //4. Print the result to the user

  }
}
\end{minted}

As we read each step it becomes apparent that we'll need a couple of variables:
one to hold the Fahrenheit (input) value and one for the Celsius (output) value.  It also
makes sense that each of these should be \mintinline{java}{double} variables as we
want to support fractional values.  So at the top of our \mintinline{java}{main} method, 
we'll add the variable declarations:

\mintinline{java}{double fahrenheit, celsius;}

We'll also need a scanner, initialized to read from the standard input: 

\mintinline{java}{Scanner s = new Scanner(System.in);}

Each of the steps is now straightforward; we'll use a \mintinline{java}{Sytem.out.println} statement in the
first step to prompt the user for input:

\mintinline{java}{System.out.println("Please enter degrees in Fahrenheit: ");}

In the second step, we'll use our \mintinline{java}{Scanner} to read in
a value from the user for the \mintinline{java}{fahrenheit} variable.  
Recall that we use the method \mintinline{java}{s.nextDouble()} to
read a \mintinline{java}{double} value from the user.

\mintinline{java}{fahrenheit = s.nextDouble();}

We can now compute \mintinline{java}{celsius} using the formula provided:

\mintinline{java}{celsius = (fahrenheit - 32) * (5 / 9);}

Finally, we use \mintinline{java}{System.out.printf} to output the result to the user:

\mintinline{java}{System.out.printf("%f Fahrenheit is %f Celsius\n", fahrenheit, celsius);}  

Try typing and running the program as defined above and you'll find that
you don't get correct answers.  In fact, you'll find that no matter what
values you enter, you get zero.  This is because of the calculation using
\mintinline{java}{(5 / 9)}: recall what happens with integer division: truncation! 
This will \emph{always} end up being zero.  

One way we could fix it would be to pull out our calculators and find that
$\frac{5}{9} = 0.55555\ldots$ and replace \mintinline{java}{(5 / 9)} with \mintinline{java}{0.555555}.
But, how many fives?  It may be difficult to tell how accurate we can make
this floating-point number by hardcoding it ourselves.  A much better approach
would be to let the compiler take care of the optimal computation for us by
making at least one of the numbers a \mintinline{java}{double} to prevent
integer truncation.  That is, we should instead use \mintinline{java}{5.0 / 9}.

The full program can be found in Code Sample \ref{code:java:fahrenheitToCelsiusProgram}.

\begin{listing}[H]
\begin{minted}{java}
package unl.cse;

import java.util.Scanner;

public class TemperatureConverter {

  public static void main(String args[]) {

    double fahrenheit, celsius;
    Scanner s = new Scanner(System.in);

    //1. Prompt the user for input in Fahrenheit
    System.out.println("Please enter degrees in Fahrenheit: ");
      
    //2. Read the Fahrenheit value from the standard input
    fahrenheit = s.nextDouble();
      
    //3. Compute the degrees Celsius
    celsius = (fahrenheit - 32) * 5.0 / 9;
      
    //4. Print the result to the user
    System.out.printf("%f Fahrenheit is %f Celsius\n", 
    	fahrenheit, celsius);

  }
}
\end{minted}
\caption{Fahrenheit-to-Celsius Conversion Program in Java}
\label{code:java:fahrenheitToCelsiusProgram}
\end{listing}

\subsection{Computing Quadratic Roots}

Some programs require the user to enter multiple inputs.  The 
prompt-input process can be repeated.  In this example, consider asking
the user for the coefficients, $a, b, c$ to a quadratic polynomial, 
  $$ax^2 + bx + c$$
and computing its roots using the quadratic formula, 
  $$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$
As before, we can create a basic program with a \mintinline{java}{main}
method and start filling in the details.  In particular, we'll need to prompt
for the input $a$, then read it in; then prompt for $b$, read it in and
repeat for $c$.  We'll also need several variables: three for the coefficients
$a, b, c$ and \emph{two} more; one for each root.  Thus, we have 

\begin{minted}{java}
    double a, b, c, root1, root2;
    Scanner s = new Scanner(System.in);

    System.out.println("Please enter a: ");
    a = s.nextDouble();
    System.out.println("Please enter b: ");
    b = s.nextDouble();
    System.out.println("Please enter c: ");
    c = s.nextDouble();
\end{minted}

Now to compute the roots: we need to take care that we correctly adapt the
formula so it accurately reflects the order of operations.  We also need to use
the standard math library's square root function (unless you want to write 
your own!  Carefully adapting the formula leads to 

\begin{minted}{java}
root1 = (-b + Math.sqrt(b*b - 4*a*c) ) / (2*a);
root2 = (-b - Math.sqrt(b*b - 4*a*c) ) / (2*a);
\end{minted}

Finally, we print the output using \mintinline{java}{System.out.printf}.  The full program 
can be found in Code Sample \ref{code:java:quadraticRootsProgram}.

\begin{listing}[h]
\begin{minted}{java}
package unl.cse;

import java.util.Scanner;

/**
 * This program computes the roots to a quadratic equation
 * using the quadratic formula.
 */
public class QuadraticRoots {

  public static void main(String args[]) {
	  
    double a, b, c, root1, root2;
    Scanner s = new Scanner(System.in);

    System.out.println("Please enter a: ");
    a = s.nextDouble();
    System.out.println("Please enter b: ");
    b = s.nextDouble();
    System.out.println("Please enter c: ");
    c = s.nextDouble();
	  
    root1 = (-b + Math.sqrt(b*b - 4*a*c) ) / (2*a);
    root2 = (-b - Math.sqrt(b*b - 4*a*c) ) / (2*a);
	  
    System.out.printf("The roots of %fx^2 + %fx + %f are: \n", 
    	a, b, c);
    System.out.printf("  root1 = %f\n", root1);
    System.out.printf("  root2 = %f\n", root2);

  }

}
\end{minted}
\caption{Quadratic Roots Program in Java}
\label{code:java:quadraticRootsProgram}
\end{listing}

This program was interactive.  As an alternative, we could have read 
all three of the inputs as command line arguments, taking care that we
need to convert them to floating-point numbers.  Lines 16--21 in the
program could have been changed to 

\begin{minted}{java}
a = Double.parseDouble(args[0]);
b = Double.parseDouble(args[1]);
c = Double.parseDouble(args[2]);
\end{minted}

Finally, think about the possible inputs a user could provide that may cause problems
for this program.  For example:
\begin{itemize}
  \item What if the user entered zero for $a$?
  \item What if the user entered some combination such that $b^2 < 4ac$?
  \item What if the user entered non-numeric values?
  \item For the command line argument version, what if the user provided less than
  	three argument?  Or more?
\end{itemize}
How might we prevent the consequences of such bad inputs?  That is, 
how might we handle the even that a users enters those bad inputs and
how do we communicate these errors to the user?  To do so we'll need 
conditionals.
