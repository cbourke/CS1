%!TEX root = ComputerScienceOne.tex

%%Chapter: PHP Basics

In the mid-1990s the \glslink{wwwLabel}{World Wide Web}
was in its infancy but
becoming more and more popular.  For the most part, web pages
contained static content: articles and text that was ``just-there.''
Web pages were far from the fully interactive and dynamic 
applications that they've become.  Rasmus Lerdorf had a home
page containing his resume and he wanted to track how many
visitors were coming to his page.  With purely static pages, this
was not possible.  So, in 1994 he developed PHP/FI which stood
for Personal Home Page tools and Forms Interpreter.  This was 
a series of binary tools written in C that operated through a 
web server's Common Gateway Interface.  When a user visited
a webpage, instead of just retrieving static content, a script
was invoked: it could do a number of operations and 
send back \gls{htmlLabel} formatted as a response.  This made
web pages much more dynamic.  By serving it through a script,
a counter could be maintained that tracked how many people
had visited the site.  Lerdorf eventually released his source
code in 1995 and it became widely used.

Today, PHP is used in a substantial number of pages on the web and
is used in many \gls{cmsLabel} applications such as Drupal and 
WordPress.  Because of its history, much of the syntax and aspects of 
PHP (now referred to as ``PHP: Hypertext Preprocessor'') are 
influenced or inspired by C.  In fact, many of the standard
functions available in the language are directly from the C
language.

PHP is a scripting language and is not compiled.  Instead, PHP
code is \emph{interpreted} by a PHP interpreter.  Though there
are several interpreters available, the de facto PHP 
interpreter is the Zend Engine, a free and open source
project that is widely available on many platforms, operating
systems, and web servers.  Because it was originally intended 
to serve web pages, PHP 
code can be \emph{interleaved} with static HTML tags.  This
allows PHP code to be embedded in web pages and dynamically
interpreted/rendered when a user requests a webpage through
a web browser.  Though rendering web pages is its primary 
purpose, PHP can be used as a general scripting language 
from the command line.

PHP is a dirty, ugly language held together by duct tape, cracked
asbestos-filled spackle and sadness (\url{http://phpsadness.com/}).  
It is the cockroach of languages: it 
is invasive and it is a survivor.  It is a hydra; rewrite one PHP app
and two more pop up.  It is much maligned and a source of ridicule.
It is the source of hundreds of bad practices, thousands of bad 
programmers, millions of bugs and an infinite abyss of security 
holes and vulnerabilities.  It is a language that was born in the
wild and raised in the darkness by two schizophrenic monkeys.
But its got character; and in this world, that's enough.

\section{Getting Started: Hello World}

The hallmark of an introduction to a new programming language is the 
\emph{Hello World!} program.  It consists of a simple program whose 
only purpose is to print the message ``Hello World!'' to the user.  
The simplicity of the program allows the focus to be on the basic syntax 
of the language.  It is also typically used to ensure that 
your development environment, interpretrer, runtime environment, 
etc.\ are functioning properly with a minimal example.  A basic Hello World! program in PHP can be found in Code Sample \ref{code:php:helloWorld}.  
A version in which the PHP code is interleaved in HTML is presented in 
Code Sample \ref{code:php:helloWorldHTML}.

\begin{listing}
\begin{minted}{php}
<?php

  printf("Hello World\n");

?>
\end{minted}
\caption{Hello World Program in PHP}
\label{code:php:helloWorld}
\end{listing}

\begin{listing}
\begin{minted}{php}
<html>
  <head>
    <title>Hello World PHP Page</title>
  </head>
  <body>
    <h1>A Simple PHP Script</h1>

    <?php printf("<p>Hello World</p>");  ?>
    
  </body>
</html>
\end{minted}
\caption{Hello World Program in PHP with HTML}
\label{code:php:helloWorldHTML}
\end{listing}

We will not focus on any particular development environment, code editor, 
or any particular operating system, interpreter, or ancillary standards in our 
presentation.  However, as a first step, you should be able to write and run the 
above program on the environment you intend to use for the rest of this book.  
This may require that you download
and install a basic PHP interpreter/development environment (such as a standard 
LAMP, WAMP or MAMP technology stack) or a full IDE (such as Eclipse, PhpStorm, etc.).

\section{Basic Elements}

Using the Hello World! program as a starting point, we will examine 
the basic elements of the PHP language.

\subsection{Basic Syntax Rules}

PHP has adopted many aspects of the C programming language 
(the interpreter itself is written in C).  However, there are some major aspects in which 
it differs from C.  The major aspects and syntactic elements of PHP include
the following.
\begin{itemize}
  \item PHP is an interpreted language: it is not compiled.  Instead it is interpreted
  	through an interpreter that parses commands in a script file line-by-line.  Any
	syntax errors, therefore, become runtime errors.
  \item PHP is \emph{dynamically typed}: you do \emph{not} declare variables or specify
  	a variable's type.  Instead, when you assign a variable a value, the variable's type
	dynamically changes to accommodate the assigned value.  Variable names \emph{always}
	begin with a dollar sign, \mintinline{text}{$}.
  \item Strings and characters are essentially the same thing (characters are strings of length 1).
  	Strings and characters can be delimited by \emph{either} single quotes \emph{or} double
	quotes.  \mintinline{php}{"this is a string"}, \mintinline{php}{'this is also a string'}; 
	\mintinline{php}{'A'} and \mintinline{php}{"a"} are both single character strings.
  \item Executable statements are terminated by a semicolon, \mintinline{php}{;}
  \item Code blocks are defined by using opening and closing curly brackets, 
  	\mintinline{php}{{ ... }}.  Moreover, code blocks can be \emph{nested}: code
	blocks can be defined within other code blocks.  
  \item A complete list of reserved and keywords can be found in the PHP Manual:
  	\url{http://php.net/manual/en/reserved.php} and \url{http://php.net/manual/en/reserved.keywords.php}
\end{itemize}

PHP also supports aspects of \gls{oopLabel} including classes and inheritance.  There
is also no memory management in PHP: it has automated garbage collection.

Though not a syntactic requirement, the proper use of whitespace is important for
good, readable code.  Code inside code blocks is indented at the same indentation.
Nested code blocks are indented further.  Think of a typical table of contents or
the outline of a formal paper or essay.  Sections and subsections or points and 
subpoints all follow proper indentation with elements at the same level at the same
indentation.  This convention is used to organize code and make it more readable.

\subsection{PHP Tags}

PHP code can be interleaved with static HTML or text.  Because of this, 
we need a way to indicate what should be interpreted as PHP and what
should be treated as static text.  We can do this using PHP \emph{tags}: the
opening tag is \mintinline{text}{<?php} and the closing tag is \mintinline{text}{?>}.
Anything placed between these tags will be interpreted as PHP code which
must adhere to the syntax rules of the language.  

A file can contain multiple opening/closing PHP tags to allow you to
interleave multiple sections of HTML or text.  When an interpreter runs
a PHP script, it will start processing the script file.  Whenever it sees the
opening PHP tag, it begins to execute the commands and stops executing
commands when it sees the closing tag.  The text outside the PHP tags is
treated as raw data. The interpreter includes it as part of its output without
modifying or processing it.

\subsection{Libraries}

PHP has many built-in functions that you can use.  These standard
libraries are loaded and available to use without any special command
to import or include them.  Full documentation on each of these
functions is maintained in the PHP manual, available online at
\url{http://php.net/}.   The manual's web
pages also contain many curated comments from PHP developers
which contain further explanations, tips \& tricks, suggestions, and
sample code to provide further assistance.  

There are many useful functions that we'll mention as we progress
through each topic.  One especially useful collection of functions is 
the math library.  This library is directly adapted from C's standard 
math library so all the function names are the same.  It provides
many common mathematical functions such as the square root and 
natural logarithm.  Table \ref{table:phpMathFunctions} highlights several of 
these functions; full documentation can be found in the PHP manual 
(\url{http://php.net/manual/en/ref.math.php}).  To use these, you 
simply ``call'' them by providing input 
and assigning the output to a variable.

\begin{minted}{php}
$x = 1.5;
$y = sqrt($x); //y now has the value $\sqrt{x} = \sqrt{1.5}$
$z = sin($x); //z now has the value $\sin{(x)} = \sin{(1.5)}$
\end{minted}

In both of the function calls above, the value of the variable \mintinline{php}{$x} is
``passed'' to the math function which computes and ``returns'' the
result which then gets assigned to another variable.

\begin{table}
\centering
\begin{tabular}{l|l}
\hline
Function & Description \\
\hline
\mintinline{php}{abs($x)}  & Absolute value, $|x|$ \\
\\
\mintinline{php}{ceil($x)} & Ceiling function, $\lceil 46.3\rceil = 47.0$\\
\mintinline{php}{floor($x)} & Floor function, $\lfloor 46.3 \rfloor =46.0$\\
\\
\mintinline{php}{cos($x)} & Cosine function\textsuperscript{a}\\
\mintinline{php}{sin($x)} & Sine function\textsuperscript{a}\\
\mintinline{php}{tan($x)} & Tangent function\textsuperscript{a}\\
\\
\mintinline{php}{exp($x)} & Exponential function, $e^x$, $e = 2.71828\ldots$ \\
\mintinline{php}{log($x)}  & Natural logarithm, $\ln{(x)}$\textsuperscript{b} \\
\mintinline{php}{log10($x)} & Logarithm base 10, $\log_{10}{(x)}$\textsuperscript{b} \\
\\
\mintinline{php}{pow($x,$y)} & The power function, computes $x^y$\textsuperscript{c}\\
\mintinline{php}{sqrt($x)} & Square root function\textsuperscript{b}\\

\hline
\end{tabular}
\caption[Several functions defined in the PHP math library]{Several functions defined in the PHP math library.  \textsuperscript{a}All trigonometric functions assume input is in \emph{radians}, \textbf{not} degrees. \textsuperscript{b}Input is assumed to be positive, $x > 0$.  \textsuperscript{c}Alternatively, PHP supports exponentiation by using \mintinline{php}{x ** y}.}
\label{table:phpMathFunctions}
\end{table}

\subsection{Comments}

Comments can be written in PHP code either as a single line using
two forward slashes, \mintinline{php}{//comment} or as a multiline comment using
a combination of forward slash and asterisk: \mintinline{php}{/* comment */}.  
With a single line comment, everything on the line \emph{after} the forward
slashes is ignored.  With a multiline comment, everything in between the forward
slash/asterisk is ignored.  Comments are ultimately ignored by the 
interpreter.  Consider the following example.

\begin{minted}{php}
//this is a single line comment
$x = 10;  //this is also a single line comment, but after some code

/*
  This is a comment that can 
  span multiple lines to format the comment
  message more clearly
*/
$y = 3.14;
\end{minted}

Most code editors and \glspl{ideLabel} will present comments in a special color or
font to distinguish them from the rest of the code (just as our example above does).
Failure to close a multiline comment will likely result in a fatal
interpreter error but with
color-coded comments its easy to see the mistake visually.

\subsection{Entry Point \& Command Line Arguments}

Every PHP script begins executing at the top of the script file and proceed in
a linear, sequential manner top-to-bottom.  In addition, you can provide a PHP
script with inputs when you run it from the command line.  These \emph{command
line arguments} are stored in two variables, \mintinline{php}{$argc} and 
\mintinline{php}{$argv}.  The first variable, \mintinline{php}{$argc} is an integer that indicates
the \emph{number} of arguments provided \emph{including} the name
of the script file being executed.  The second, \mintinline{php}{$argv} 
is an array (see Section \ref{chapter:php:arrays}) of strings consisting 
of the command line arguments.  
To access them, you can \emph{index} them starting at zero, the first 
being \mintinline{php}{$argv[0]}, the second \mintinline{php}{$argv[1]},  
the last one would be \mintinline{php}{$argv[$argc-1]}.  
The first one is always the name of the script file being run.  The 
remaining are the command line arguments provided by the user
when the script is executed.  We'll see several examples later.

\section{Variables}

PHP is a dynamically typed language.  As a consequence, you do not declare
variables before you start using them.  If you need to store a value into a variable, 
you simply name the variable and use an assignment operator to assign the
value.  Since you do not declare variables, you also do not specify a variable's
type.  If you assign a string value to a variable, its type becomes a string.  If you
assign an integer to a variable, its type becomes an integer.  If you reassign
the value of a variable to a value with a different type, the variable's type
also changes.  

Internally PHP supports several different types: Booleans, 
integers, floating point numbers, strings, arrays, and objects.
The way that integers are represented may be platform dependent, but 
are usually 32-bit signed two's complement integers, able to represent
integers between $-2,147,483,648$ and 2,147,483,647.  Floating point 
numbers are also platform dependent, but are usually
64-bit double precision numbers defined by the \gls{ieeeLabel} 754 standard,
providing about 16 digits of precision.  Strings 
and single characters are the same thing in PHP.  Strings are
represented as sequences of characters from the extended ASCII text 
table (see Table \ref{table:asciiTable}) which includes all characters in
the range 0--255.  PHP does not have native Unicode support for 
international characters.

\subsection{Using Variables}

To use a variable in PHP, you simply need to assign a value to a named
variable identifier and the variable is in scope.  Variable names
\emph{always} begin with a single dollar sign, \mintinline{text}{$}.
The assignment operator is a single equal sign, \mintinline{php}{=} 
and is a right-to-left assignment.  The variable that we wish to 
assign the value to appears on the left-hand-side while the value 
(literal, variable or expression) is on the right-hand-size.  For example:

\begin{minted}{php}
$numUnits = 42;
$costPerUnit = 32.79;
$firstInitial = "C";
\end{minted}

Each assignment also implicitly changes the variable's type.  Each of the
variables above becomes an integer, floating point number, and string 
respectively.  Assignment statements are terminated by a semicolon like
most executable statements in PHP.  The identifier rules are fairly standard: 
a variable's name can consist of lowercase and uppercase alphabetic characters, 
numbers, and underscores.  You can also use the extended ASCII character
set in variable names but it is not recommended (umlauts and other diacritics
can easily be confused).  Variable names are \emph{case sensitive}.  As
previously mentioned, variable names must \emph{always} begin with a dollar
sign, \mintinline{text}{$}.  Stylistically, we adopt the modern lower
camel casing naming convention for variables in our code.

If you do not assign a value to a variable, that variable remains undefined
or ``unset.''  Undefined variables are treated as \mintinline{php}{null} in PHP.
The concept of ``null'' refers to uninitialized, undefined, empty, missing, or
meaningless values.  In PHP the keyword \mintinline{php}{null} is used which
is case insensitive (\mintinline{php}{null}, \mintinline{php}{Null} and \mintinline{php}{NULL}
are all the same), but for consistency, we'll use \mintinline{php}{null}.  
When \mintinline{php}{null} values are used in arithmetic expressions, 
\mintinline{php}{null} is treated as zero.  So, \mintinline{php}{(10 + null)} is
equal to 10.  When \mintinline{php}{null} is used in the context of strings, 
it is treated as an empty string and ignored.  When used in a Boolean
expression or conditional, \mintinline{php}{null} is treated as \mintinline{php}{false}.

PHP also allows you to define \emph{constants}: values that cannot 
be changed once set.  To define a constant, you invoke a function 
named \mintinline{php}{define} and providing a name and value.

\begin{minted}{php}
define("PI", 3.14159);
define("INSTITUTION", "University of Nebraska-Lincoln");
define("COST_PER_UNIT", 2.50);
\end{minted}

Constant names are case sensitive.  By convention, we use uppercase
underscore casing.  An attempt to redefine a constant value will raise a 
script warning, but will ultimately have no effect.  When referring to constants
later in the script, you use the constant's name.  You do not
treat it as a string, nor do you use a dollar sign. For example:

\mintinline{php}{$area = $r * $r * PI;}

\section{Operators}

PHP supports the standard arithmetic operators for addition, subtraction, 
multiplication, and division using \mintinline{php}{+}, \mintinline{php}{-}, 
\mintinline{php}{*}, and \mintinline{php}{/} respectively.  Each of these 
operators is a binary operator that acts on two operands which can either 
be literals, variables or expressions and follow the usual rules of 
arithmetic when it comes to order of precedence (multiplication 
and division before addition and subtraction).

\begin{minted}{php}
$a = 10, $b = 20, $c = 30;
$d = $a + 5;
$d = $a + $b;
$d = $a - $b;
$d = $a + $b * $c;
$d = $a * $b; //d becomes a floating point number with a value .5

$x = 1.5, $y = 3.4, $z = 10.5;
$w = $x + 5.0;
$w = $x + $y;
$w = $x - $y;
$w = $x + $y * $z;
$w = $x * $y;
$w = $x / $y;

//mixing integers and floating point numbers is no problem
$w = $a + $x;  
\end{minted}

PHP also supports the integer remainder operator using the \mintinline{php}{%} symbol.
This operator gives the remainder of the result of dividing two integers.  Examples:

\begin{minted}{php}
$x = 10 % 5; //x is 0
$x = 10 % 3; //x is 1
$x = 29 % 5; //x is 4
\end{minted}

\subsection{Type Juggling}

The expectations of an arithmetic expression involving two variables that 
are either integers or floating point numbers are straightforward.  We 
expect the sum/product/etc.\ as a result.  However, since PHP is 
dynamically typed, a variable involved in an
arithmetic expression could be anything, including a Boolean, object, array, or string.
When a Boolean is involved in an arithmetic expression, \mintinline{php}{true} is 
treated as 1 and \mintinline{php}{false} is treated as zero.  If an array is involved
in an expression, it is usually a fatal error.\footnote{PHP does allow you to ``add''
two arrays together which results in their union.}  Non-null objects are treated as 1
and \mintinline{php}{null} is treated as 0.

However, when string values are involved in an arithmetic expression, PHP
does something called \emph{type juggling}. \index{type juggling} When juggled,
an attempt is made to convert a string variable into a numeric value by parsing
it.  The parsing goes over each numeric character, converting the value to a 
numeric type (either an integer or floating point number).  The first type a
non-numeric character is encountered, the parsing stops and the value parsed
\emph{so far} is the value used in the expression.

Consider the examples in Code Sample \ref{code:php:typeJuggling}.
In the first segment, \mintinline{php}{$a} is type juggled to the value 
$10$, then added to \mintinline{php}{5}, resulting in 15.  In the second 
example, \mintinline{php}{$a}
represents a floating point number, and is converted to $3.14$, the result
of adding to 5 is thus $8.14$.  In the third example, the string does not
contain any numerical values.  In this case, the parsing stops at
the first character and what has been parsed \emph{so far} is zero!
Finally, in the last example, the first two characters in \mintinline{php}{$a}
are numeric, so the parsing ends at the third character, and what
has been parsed \emph{so far} is $10$.

\begin{listing}
\begin{minted}{php}
$a = "10";
$b = 5 + $a; //b = 15

$a = "3.14";
$b = 5 + $a; //b = 8.14

$a = "ten";
$b = 5 + $a; //b = 5

//partial conversions also occur:
$a = "10ten";
$b = 5 + $a; //b = 15
\end{minted}
\caption{Type Juggling in PHP}
\label{code:php:typeJuggling}
\end{listing}

Relying on type juggling to convert values can be ugly and error prone.  
You can write much more intentional code by using the several conversion
functions provided by PHP.  For example:

\begin{minted}{php}
$a = intval("10");
$b = floatval("3.14");
$c = intval("ten"); //c has the value zero
\end{minted}

In all three of the examples above, the strings are converted just as 
they are when type juggled.  However, the variables are \emph{guaranteed}
to have the type indicated (integer or floating point number).  

There are several utility functions that can be used to help
determine the type of variable.  The function \mintinline{php}{is_numeric($x)}
returns \mintinline{php}{true} if \mintinline{php}{$x} is a numeric (integer
or floating point number) or represents a \emph{pure} numeric string.
The functions \mintinline{php}{is_int($x)} and \mintinline{php}{is_float($x)} each return
\mintinline{php}{true} or \mintinline{php}{false} depending on whether
or not \mintinline{php}{$x} is of that type.

\begin{minted}{php}
$a = 10;
$b = "10";
$c = 3.14;
$d = "3.14";
$e = "hello";
$f = "10foo";

is_numeric($a); //true
is_numeric($b); //true
is_numeric($c); //true
is_numeric($d); //true
is_numeric($e); //false
is_numeric($f); //false

is_int($a); //true
is_int($b); //false
is_int($c); //false
is_int($d); //false
is_int($e); //false
is_int($f); //false

is_float($a); //false
is_float($b); //false
is_float($c); //true
is_float($d); //false
is_float($e); //false
is_float($f); //false
\end{minted}

A more general way to determine the type of a variable is to use the 
function \mintinline{php}{gettype($x)} which returns a string
representation of the type of the variable \mintinline{php}{$x}.
The string returned by this function is one of the following depending
on the type of \mintinline{php}{$x}:  \mintinline{php}{"boolean"}, 
\mintinline{php}{"integer"}, \mintinline{php}{"double"},
\mintinline{php}{"string"}, \mintinline{php}{"array"},
\mintinline{php}{"object"}, \mintinline{php}{"resource"},
\mintinline{php}{"NULL"}, or \mintinline{php}{"unknown type"}.

Other checker functions allow you to determine if a variable
has been set, if its null, ``empty'' etc.  For example, 
\mintinline{php}{is_null($x)} returns \mintinline{php}{true} if 
\mintinline{php}{$x} is not set or is set, but has been set to \mintinline{php}{null}.
The function \mintinline{php}{isset($x)} returns \mintinline{php}{true} 
only if \mintinline{php}{$x} is set and it is not \mintinline{php}{null}.
The function \mintinline{php}{empty($x)} returns \mintinline{php}{true} 
if \mintinline{php}{$x} represents an empty entity: an empty string, 
\mintinline{php}{false}, an empty array, \mintinline{php}{null}, 
\mintinline{php}{"0"}, 0, or an unset variable. Several examples 
are presented in Table \ref{table:phpTestingFunctions}.

\begin{table}
\centering
\begin{tabular}{|l|c|c|c|}
\hline
Value of \mintinline{php}{$var} & \mintinline{php}{isset($var)} & \mintinline{php}{empty($var)} & \mintinline{php}{is_null($var)} \\
\hline\hline
\mintinline{php}{42} & bool(true) & bool(false) & bool(false) \\
\hline
\mintinline{php}{""} (an empty string) & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{" "} (space) & bool(true) & bool(false) & bool(false) \\
\hline
\mintinline{php}{false} & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{true} & bool(true) & bool(false) & bool(false) \\
\hline
\mintinline{php}{array()} (an empty array) & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{null} & bool(false) & bool(true) & bool(true) \\
\hline
\mintinline{php}{"0"} (0 as a string) & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{0} (0 as an integer) & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{0.0} (0 as a float) & bool(true) & bool(true) & bool(false) \\
\hline
\mintinline{php}{var $var;} (declared with no value) & bool(false) & bool(true) & bool(true) \\
\hline
\mintinline{php}{NULL} byte (\mintinline{php}{"\0"}) & bool(true)	 & bool(false) & bool(false) \\
\hline
\end{tabular}
\caption{Results for various variable values}
\label{table:phpTestingFunctions}
\end{table}

\subsection{String Concatenation}

Strings in PHP can be concatenated (combined) in several different ways.
One way you can combine strings is by using the concatenation operator.
In PHP the string concatenation operator is a single period.

\begin{minted}{php}
$s = "Hello";
$t = "World!";
$msg = $s . " " . $t; //msg contains "Hello World!"
\end{minted}

Another way you can combine strings is by placing variables directly
inside a string.  The variables inside the string are replaced with the variable's values.  Example:

\begin{minted}{php}
$x = 13;
$name = "Starlin";
$msg = "Hello, $name, your number is $x";
//msg contains the string "Hello, Starlin, your number is 13"
\end{minted}

\section{Basic I/O}

Recall the main purpose of PHP is as a scripting language to serve dynamic
webpages.  However, it does support
input and output from the standard input/output.  There are several
ways to print output to the standard output.  The keywords
\mintinline{php}{print} and \mintinline{php}{echo} (which are aliases
of each other) allow you to print any variable or string.  PHP also has 
a \mintinline{php}{printf()} function to allow formatted output.  Some
examples:

\begin{minted}{php}
$a = 10;
$b = 3.14;

print $a;
print "The value of a is $a\n"; 

echo $a;
echo "The value of a is $a\n"; 

printf("The value of a is %d, and b is %f\n", $a, $b);
\end{minted}

There are also several ways to perform standard input, but the easiest is to
use \mintinline{php}{fgets} (short for \textbf{f}ile \textbf{get s}tring) using the
keyword \mintinline{php}{STDIN} (Standard Input).  This function will return, 
as a string, everything the user enters up to \emph{and including} the enter
key (interpreted as the endline character, \mintinline{text}{\n}).  To remove
the endline character, you can use another function, \mintinline{php}{trim}
which removes leading and trailing whitespace from a string.  A full example:

\begin{minted}{php}
//prompt the user to enter input
printf("Please enter a number: ");
$a = fgets(STDIN);
$a = trim($a);
\end{minted}

Alternatively, lines 3--4 could be combined into one: 
\mintinline{php}{$a = trim(fgets(STDIN));} The call to 
\mintinline{php}{fgets} \emph{waits} (referred to as ``blocking'')
for the user to enter input.  The user is free to start typing.  When the user 
is done, they hit the enter key at which point the program resumes and reads 
the input from the standard input buffer, and returns it as a string value which
we assign to the variable \mintinline{php}{$a}.

The standard input is unstructured.  The user is free to type whatever they want.
If we prompt the user for a number but they just start mashing the keyboard giving 
non-numerical input, we may get incorrect results.  We can use the 
conversion functions mentioned above to attempt to properly convert the values.
However, this only guarantees that the resulting variable is of the type we want
(integer or floating point value for example).  The standard input is not a good mechanism 
for reading input, but it provides a good starting point to develop a few
simple programs.

\section{Examples}

\subsection{Converting Units}

Let's write a program that prompts 
the user to enter a temperature in degrees Fahrenheit and convert it 
to degrees Celsius using the formula
  $$C = (F - 32) \cdot \frac{5}{9}$$

We begin with the basic script shell with the opening and closing
PHP tags and some comments documenting the purpose of our
script.

\begin{minted}{php}
<?php

/**
 * This program converts Fahrenheit temperatures to 
 * Celsius
 */

//TODO: implement this

?>
\end{minted}

It is common for programmers to use a comment along with a 
\mintinline{php}{TODO} note to themselves as a reminder of things 
that they still need to do with the program.  Let's first outline 
the basic steps that our program will go through:
\begin{enumerate}
  \item We'll first prompt the user for input, asking them for a temperature in Fahrenheit
  \item Next we'll read the user's input and use a conversion function 
    to ensure the input is a floating point number
  \item Once we have the input, we can calculate the degrees Celsius by using the formula above
  \item Lastly, we will want to print the result to the user to inform them of the value
\end{enumerate}
Sometimes it is helpful to write an outline of such a program directly in the code using
comments to provide a step-by-step process.  For example:

\begin{minted}{php}
<?php

/**
 * This program converts Fahrenheit temperatures to 
 * Celsius
 */

//TODO: implement this

//1. Prompt the user for input in Fahrenheit
//2. Read the Fahrenheit value from the standard input
//3. Compute the degrees Celsius
//4. Print the result to the user

?>
\end{minted}

As we read each step it becomes apparent that we'll need a couple of 
variables: one to hold the Fahrenheit (input) value and one for the Celsius 
(output) value.  We'll want to ensure that these are floating point numbers
which we can do by making some explicit conversion.  We use a 
\mintinline{php}{printf()} statement in the first step to prompt 
the user for input.

\mintinline{php}{printf("Please enter degrees in Fahrenheit: ");}

In the second step, we'll use the standard input to read the \mintinline{php}{$fahrenheit} 
variable value from the user.  Recall that we can use \mintinline{php}{fgets} to read
from the standard input, but may have to \mintinline{php}{trim} the trailing whitespace.

\mintinline{php}{$fahrenheit = trim(fgets(STDIN));}

If we want to ensure that the variable \mintinline{php}{$fahrenheit} is a floating point
value, we can use \mintinline{php}{floatval()}:

\mintinline{php}{$fahrenheit = floatval($fahrenheit);}

We can now compute \mintinline{php}{$celsius} using the formula provided:

\mintinline{php}{$celsius = ($fahrenheit - 32) * (5 / 9);}

Finally, we use \mintinline{php}{printf()} again to output the result to the user:

\mintinline{php}{printf("%f Fahrenheit is %f Celsius\n", $fahrenheit, $celsius);}  

The full program can be found in Code Sample \ref{code:php:fahrenheitToCelsiusProgram}.

\begin{listing}[H]
\begin{minted}{php}
<?php

/**
 * This program converts Fahrenheit temperatures to
 * Celsius
 */

//1. Prompt the user for input in Fahrenheit
printf("Please enter degrees in Fahrenheit: ");

//2. Read the Fahrenheit value from the standard input
$fahrenheit = trim(fgets(STDIN));
$fahrenheit = floatval($fahrenheit);

//3. Compute the degrees Celsius
$celsius = ($fahrenheit - 32) * (5/9);

//4. Print the result to the user
printf("%f Fahrenheit is %f Celsius\n", $fahrenheit, $celsius);

?>
\end{minted}
\caption{Fahrenheit-to-Celsius Conversion Program in PHP}
\label{code:php:fahrenheitToCelsiusProgram}
\end{listing}

\subsection{Computing Quadratic Roots}

Some programs require the user to enter multiple inputs.  The 
prompt-input process can be repeated.  In this example, consider asking
the user for the coefficients, $a, b, c$ to a quadratic polynomial, 
  $$ax^2 + bx + c$$
and computing its roots using the quadratic formula, 
  $$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}$$
As before, we can create a basic program with PHP tags and start 
filling in the details.  In particular, we'll need to prompt
for the input $a$, then read it in; then prompt for $b$, read it in and
repeat for $c$.  Thus, we have 

\begin{minted}{php}
printf("Please enter a: ");
$a = floatval(trim(fgets(STDIN)));
printf("Please enter b: ");
$b = floatval(trim(fgets(STDIN)));
printf("Please enter c: ");
$c = floatval(trim(fgets(STDIN)));
\end{minted}

We need to take care that we correctly adapt the formula so it accurately 
reflects the order of operations.  We also need to use the math library's 
square root function.  

\begin{minted}{php}
$root1 = (-$b + sqrt($b*$b - 4*$a*$c) ) / (2*$a);
$root2 = (-$b - sqrt($b*$b - 4*$a*$c) ) / (2*$a);
\end{minted}

Finally, we print the output using \mintinline{php}{printf()}.  The full program 
can be found in Code Sample \ref{code:php:quadraticRootsProgram}.

\begin{listing}[h]
\begin{minted}{php}
<?php

/**
 * This program computes the roots to a quadratic equation
 * using the quadratic formula.
 */

printf("Please enter a: ");
$a = floatval(trim(fgets(STDIN)));
printf("Please enter b: ");
$b = floatval(trim(fgets(STDIN)));
printf("Please enter c: ");
$c = floatval(trim(fgets(STDIN)));

$root1 = (-$b + sqrt($b*$b - 4*$a*$c) ) / (2*$a);
$root2 = (-$b - sqrt($b*$b - 4*$a*$c) ) / (2*$a);

printf("The roots of %fx^2 + %fx + %f are: \n", $a, $b, $c);
printf("  root1 = %f\n", $root1);
printf("  root2 = %f\n", $root2);

?>
\end{minted}
\caption{Quadratic Roots Program in PHP}
\label{code:php:quadraticRootsProgram}
\end{listing}

This program was interactive.  As an alternative, we could have read 
all three of the inputs as command line arguments, taking care 
to convert them to floating point numbers.  Lines 8--13 in the
program could have been changed to 

\begin{minted}{php}
$a = floatval($argv[1]);
$b = floatval($argv[2]);
$c = floatval($argv[3]);
\end{minted}

Finally, think about the possible input a user could provide that may cause problems
for this program.  For example:
\begin{itemize}
  \item What if the user entered zero for $a$?
  \item What if the user entered some combination such that $b^2 < 4ac$?
  \item What if the user entered non-numeric values?
  \item For the command line argument version, what if the user provided less than
  	three arguments?  Or more?
\end{itemize}
How might we prevent the consequences of such bad input?  
How might we handle the event that a user enters bad input and
how do we communicate these errors to the user?  To begin to resolve
these issues, we'll need conditionals.





