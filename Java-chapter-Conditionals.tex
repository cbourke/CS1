%!TEX root = ComputerScienceOne.tex

%%Chapter: Java Conditionals

Java supports the basic if, if-else, and if-else-if conditional structures as well as switch
statements.  Java has Boolean types and logical statements are built using the standard 
logical operators for numeric comparisons as well as logical operators such as negations, 
\And, and \Or that can be used with Boolean types.

\section{Logical Operators}

Recall that Java has Boolean types built-in to the language using
either the primitive type, \mintinline{java}{boolean} or its wrapper class
\mintinline{java}{Boolean}.  Moreover, the keywords \mintinline{java}{true}
and \mintinline{java}{false} can be used to assign and check values.
Because Java has Boolean types, it does not allow you to mix logical operators
with numeric types.  That is, code like the following is invalid.

\begin{minted}{java}
int a = 10;
boolean b = true;
boolean result = (a || b); //compilation error
\end{minted}

The standard numeric comparison operators are also supported.  Consider the 
following code snippet:

\begin{minted}{java}
int a = 10;
int b = 20;
int c = 10;
boolean x = true;
boolean y = false;
\end{minted}

The six standard comparison operators are presented in Table \ref{table:java:comparisonOperators}
using these variables as examples.  The comparison operators are the same when
used with \mintinline{java}{double} types as well and \mintinline{java}{int} types and 
\mintinline{java}{double} types can be compared with each other without type casting.

\begin{table}
\centering
\begin{tabular}{l|l|l|l}
Name & Operator Syntax & Examples  & Value \\
\hline\hline
Equals & \mintinline{java}{==} & 
	\mintinline{java}{a == 10} & \True \\
~ & ~ & \mintinline{java}{b == 10} & \False \\
~ & ~ & \mintinline{java}{a == b} & \False \\
~ & ~ & \mintinline{java}{a == c} & \True \\
\hline	
Not Equals & \mintinline{java}{!=} & 
	\mintinline{java}{a != 10} & \False \\
~ & ~ & \mintinline{java}{b != 10} & \True \\
~ & ~ & \mintinline{java}{a != b} & \True \\
~ & ~ & \mintinline{java}{a != c} & \False \\
\hline	
Strictly Less Than & \mintinline{java}{<} & 
	\mintinline{java}{a < 15} & \True \\
~ & ~ & \mintinline{java}{a < 5} & \False \\
~ & ~ & \mintinline{java}{a < b} & \True \\
~ & ~ & \mintinline{java}{a < c} & \False \\
\hline
Less Than Or Equal To & \mintinline{java}{<=} & 
	\mintinline{java}{a <= 15} & \True \\
~ & ~ & \mintinline{java}{a <= 5} & \False \\
~ & ~ & \mintinline{java}{a <= b} & \True \\
~ & ~ & \mintinline{java}{a <= c} & \True \\
\hline
Strictly Greater Than & \mintinline{java}{>} & 
	\mintinline{java}{a > 15} & \False \\
~ & ~ & \mintinline{java}{a > 5} & \True \\
~ & ~ & \mintinline{java}{a > b} & \False \\
~ & ~ & \mintinline{java}{a > c} & \False \\
\hline
Greater Than Or Equal To & \mintinline{java}{>=} & 
	\mintinline{java}{a >= 15} & \False \\
~ & ~ & \mintinline{java}{a >= 5} & \True \\
~ & ~ & \mintinline{java}{a >= b} & \False \\
~ & ~ & \mintinline{java}{a >= c} & \True \\
\hline	
\end{tabular}
\caption{Comparison Operators in Java}
\label{table:java:comparisonOperators}
\end{table}

Furthermore, because of autoboxing and unboxing, the wrapper classes for 
numeric types can be compared using the same operators.  For example:

\begin{minted}{java}
int a = 10;
Integer b = 20;
Double x = 3.14;
boolean r;
r = (a < b);
r = (a >= b);
r = (x == 2.71);
\end{minted}

The three basic logical operators are also supported as described in 
Table \ref{table:java:logicOperators} using the same code snippet variable
values as examples.

\begin{table}
\centering
\begin{tabular}{l|l|l|l}
Operator & Operator Syntax & Examples & Values \\
\hline\hline
Negation & \mintinline{java}{!} & 
	\mintinline{java}{!x} & \False \\
~ & ~ & \mintinline{java}{!y} & \True \\
\hline
\And & \mintinline{java}{&&} & 
	\mintinline{java}{x && true} & \True \\
~ & ~ & \mintinline{java}{x && y} & \False \\
\hline
\Or & \mintinline{java}{||} & 
	\mintinline{java}{x || false} & \True \\
~ & ~ & \mintinline{java}{x || y} & \False \\
\end{tabular}
\caption{Logical Operators in Java}
\label{table:java:logicOperators}
\end{table}

\subsection{Order of Precedence}

At this point it is worth summarizing the order of precedence of all the 
operators that we've seen so far including assignment, arithmetic, 
comparison, and logical.  Since all of these operators could be used
in one statement, for example, 

\mintinline{java}{(b*b < 4*a*c || a == 0 || args.length != 4)}

it is important to understand the order in which each one gets evaluated.
Table \ref{table:java:operatorPrecedence} summarizes the order of precedence
for the operators seen so far.  This is not an exhaustive list of Java operators.

\begin{table}
\centering
\begin{tabular}{l|l|l|p{6cm}}
~ & Operator(s) & Associativity & Notes \\
\hline\hline
Highest & \mintinline{java}{++}, \mintinline{java}{--} & left-to-right & postfix increment operators\\
~ & \mintinline{java}{-},  \mintinline{java}{!} & right-to-left & unary negation operator, logical not\\
~ & \mintinline{java}{*},  \mintinline{java}{/}, \mintinline{java}{%} & left-to-right & ~\\
~ & \mintinline{java}{+},  \mintinline{java}{-} & left-to-right & addition, subtraction\\
~ & \mintinline{java}{<},  \mintinline{java}{<=}, \mintinline{java}{>}, \mintinline{java}{>=} & left-to-right & comparison \\
~ & \mintinline{java}{==},  \mintinline{java}{!=} & left-to-right & equality, inequality \\
~ & \mintinline{java}{&&} & left-to-right & logical \And \\
~ & \mintinline{java}{||}  & left-to-right & logical \Or \\
Lowest & \mintinline{java}{=}, \mintinline{java}{+=}, \mintinline{java}{-=}, \mintinline{java}{*=}, \mintinline{java}{/=}  & right-to-left & assignment and compound assignment operators \\
\end{tabular}
\caption[Operator Order of Precedence in Java]{Operator Order of Precedence in Java.
Operators on the same level have equivalent order and are performed in the associative
order specified.}
\label{table:java:operatorPrecedence}
\end{table}

\subsection{Comparing Strings and Characters}

The comparison operators in Table \ref{table:java:comparisonOperators} can also be used
for \emph{single characters} because of the nature of the ASCII text table (see Table \ref{table:asciiTable}).
Each alphanumeric character, including the various symbols and whitespace characters, 
is associated with an integer 0--127.  We can therefore write statements like \mintinline{java}{('A' < 'a')}, 
which is \True since uppercase letters are ordered before lowercase letters in the ASCII
table (\mintinline{java}{('A'} is 65 and \mintinline{java}{('a'} is 97 and so $65 < 97$ is \True).
Several more examples can be found in Table \ref{table:java:asciiComparisonExamples}.

\begin{table}[h]
\centering
\begin{tabular}{c|l}
Comparison Example & Result \\
\hline\hline
\mintinline{java}{('A' < 'a')} & \True \\ 
\mintinline{java}{('A' == 'a')} & \False \\ 
\mintinline{java}{('A' < 'Z')} & \True \\ 
\mintinline{java}{('0' < '9')} & \True \\ 
\mintinline{java}{('\n' < 'A')} & \True \\ 
\mintinline{java}{(' ' < '\n')} & \False \\ 
\end{tabular}
\caption{Character comparisons in Java}
\label{table:java:asciiComparisonExamples}
\end{table}

Numeric comparison operators \emph{cannot} be used to compare strings in Java.  For example,
we could \emph{not} code something like \mintinline{java}{("aardvark" < "zebra")}.  The Java
compiler would not allow you to do this because the comparison operator is for numeric types 
\emph{only}.  However, the following code \emph{would} compile and run:

\begin{minted}{java}
String s = "aardvark";
String t = "zebra";
boolean b = (s == t);
\end{minted}

but it wouldn't necessarily give you what you want.  To understand why this is okay, recall that
a \mintinline{java}{String} is an object; the \mintinline{java}{s} and \mintinline{java}{t} variables
are \emph{references} to that object in memory.  When we use the equality comparison, \mintinline{java}{==}
we're asking if \mintinline{java}{s} and \mintinline{java}{t} are the \emph{same memory address}.
In this case, likely they are not and so the result is \mintinline{java}{false}.  However, similar code, 
for example, 

\begin{minted}{java}
String s = new String("liger");
String t = new String("liger");
boolean b = (s == t);
\end{minted}

would also result in \mintinline{java}{false} because \mintinline{java}{s} and \mintinline{java}{t} represent
different strings in memory, even though they have the same sequence of characters.
We'll explore how to properly compare strings later.  For now, avoid using the
comparison operators with strings.

\section{If, If-Else, If-Else-If Statements}

Conditional statements in Java utilize the keywords \mintinline{java}{if}, \mintinline{java}{else}, and
\mintinline{java}{else if}.  Conditions are placed inside parentheses immediately after the 
\mintinline{java}{if} and \mintinline{java}{else if} keywords.  Examples of all three can be 
found in Code Sample \ref{code:java:conditionalExamples}.

\begin{listing}
\begin{minted}{java}
//example of an if statement:
if(x < 10) {
  System.out.println("x is less than 10");
}

//example of an if-else statement:
if(x < 10) {
  System.out.println("x is less than 10");
} else {
  System.out.println("x is 10 or more");
}

//example of an if-else-if statement:
if(x < 10) {
  System.out.println("x is less than 10");
} else if(x == 10) {
  System.out.println("x is equal to ten");
} else {
  System.out.println("x is greater than 10");
}
\end{minted}
\caption{Examples of Conditional Statements in Java}
\label{code:java:conditionalExamples}
\end{listing}

Some observations about the syntax: the statement, \mintinline{java}{if(x < 10)}
does not have a semicolon at the end.  This is because it is a conditional statement
that determines the flow of control and \emph{not} an executable statement.  
Therefore, no semicolon is used.  Suppose we made a mistake and \emph{did}
include a semicolon:

\begin{minted}{java}
int x = 15;
if(x < 10); {
  System.out.println("x is less than 10");
}
\end{minted}

Some compilers may give a warning, but this is valid Java; it will compile and it 
will run.  However, it will end up printing \mintinline{java}{x is less than 10}, even
though $x = 15$!  Recall that a conditional statement \emph{binds} to the 
executable statement or code block \emph{immediately} following it.  In this
case, we've provided an \emph{empty} executable statement ended by the
semicolon.  The code is essentially equivalent to 

\begin{minted}{java}
int x = 15;
if(x < 10) {
}
System.out.println("x is less than 10");
\end{minted}

Which is obviously not what we wanted.  The semicolon ended up binding 
to the empty executable statement, and the code block containing the
print statement immediately followed, but was \emph{not} bound to the
conditional statement which is why the print statement executed regardless
of the value of $x$.

Another convention that we've used in our code is where we have placed the
curly brackets.  First, if a conditional statement is bound to only one statement, 
the curly brackets are not necessary.  However, it is best practice to include them
even if they are not necessary and we'll follow this convention.  Second, the
opening curly bracket is on the same line as the conditional statement while
the closing curly bracket is indented to the same level as the start of the
conditional statement.  Moreover, the code inside the code block is indented.
If there were more statements in the block, they would have all been at the
same indentation level.

%\section{Switch statements}
%
%TODO: should we actually do this?
%
%C also supports switch statements, but only for integer types.  The usual
%syntax applies as do the fall-through rules.  Switch statements also work 
%on \mintinline{java}{char} types since in C, they can be treated as integers
%according to the ASCII text table.
%
%\begin{listing}[H]
%\begin{minted}{c}
%int x;
%...
%switch(x) {
%  case 0: 
%    printf("x is zero\n");
%    break;
%  case 1:
%  case 2:
%    printf("x is one or 2\n");
%    break;
%  case 3:
%    printf("x is 3\n");
%    break;
%  case 10:
%    printf("x is 10\n");
%    break;
%  default:
%    printf("x is not 0, 1, 2, 3, nor 10\n");
%    break;
%}
%\end{minted}
%\caption{Switch Statement in C}
%\label{code:c:switchStatement}
%\end{listing}
%
%TODO: more here?

\section{Examples}

\subsection{Computing a Logarithm}

The logarithm of $x$ is the exponent that some \emph{base} must 
be raised to get $x$.  The most common logarithm is the natural logarithm, 
$\ln{(x)}$ which is base $e = 2.71828\ldots$.  But logarithms can be in any base 
$b > 1$\footnote{Bases can also be $0< b < 1$, but we'll restrict our attention to
increasing functions only.}  What if we wanted to compute $\log_2{(x)}$?  
Or $\log_{\pi}{(x)}$?  Let's write a program that will prompt the user for a
number $x$ and a base $b$ and computes $\log_b{(x)}$.

Arbitrary bases can be computed using the change of base formula: 
  $$\log_b(x) = \frac{\log_a{(x)}}{\log_a{(b)}}$$
If we can compute \emph{some} base $a$, then we can compute any base 
$b$.  Fortunately we have such a solution.  Recall that the standard library 
provides a function to compute the natural logarithm, \mintinline{java}{Math.log()}).
This is one of the fundamentals of problems solving: if a solution already 
exists, use it.  In this case, a solution exists for a different, but similar problem
(computing the natural logarithm), but we can \emph{adapt} the solution 
using the change of base formula.  In particular, if we have variables 
\mintinline{java}{b} (base) and \mintinline{java}{x}, we can compute $\log_b{(x)}$ using

  \mintinline{java}{Math.log(x) / Math.log(b)}
  
But wait: we have a problem similar to the examples in the previous section.  
The user could enter invalid values such as $b = -10$ or $x = -2.54$ 
(logarithms are undefined for non-positive values in any base).  We want
to ensure that $b > 1$ and $x > 0$.  With conditionals, we can now do this.  
Once we have read in the input from the user we can make a check for
good input using an \mintinline{java}{if} statement.

\begin{minted}{java}
if(x <= 0 || b <= 1) {
  System.out.println("Error: bad input!");
  System.exit(1);
}
\end{minted}

This code has something new: \mintinline{java}{System.exit(1)}.  The \mintinline{java}{exit}
function immediately terminates the program regardless of the rest of the
code that may remain.  The argument passed to \mintinline{java}{exit} is an 
integer that represents an \emph{error code}.  The convention is that 
zero indicates ``no error'' while non-zero values indicate some error.  This
is a simple way of performing \emph{error handling}: if the user provides
bad input, we inform them and quit the program, forcing them to run it
again and provide good input.  By prematurely terminating the program
we avoid any illegal operation that would give a bad result.

Alternatively, we could have split the conditions into two statements and given
a more descriptive error message.  We use this design in the full program 
which can be found in Code Sample \ref{code:java:logarithmProgram}.  The 
program also takes the input as command line arguments.  Now that we have
conditionals, we can actually check that the correct number of arguments
was provided by the user and quit in the event that they don't provide
the correct number.

\begin{listing}[h]
\begin{minted}{java}
/**
 * This program computes the logarithm base b (b > 1) 
 * of a given number x > 0
 */
public class Logarithm {

  public static void main(String args[]) {

    double b, x, result;
    if(args.length != 2) {
      System.out.println("Usage: b x");
      System.exit(1);
    }  
	  
    b = Double.parseDouble(args[0]);
    x = Integer.parseInt(args[1]);

    if(x <= 0) {
      System.out.println("Error: x must be greater than zero");
      System.exit(1);
    }
    if(b <= 1) {
      System.out.println("Error: base must be greater than one");
      System.exit(1);
    }

    result = Math.log(x) / Math.log(b);
    System.out.printf("log_(%f)(%f) = %f\n", b, x, result);

  }

}
\end{minted}
\caption{Logarithm Calculator Program in Java}
\label{code:java:logarithmProgram}
\end{listing}

\subsection{Life \& Taxes}

Let's adapt the conditional statements we developed in Section \ref{subsubsection:lifeAndTaxes}
into a full Java program.  The first thing we need to do is establish the variables we'll need and
read them in from the user.  At the same time we can check for bad input (negative values)
for both the inputs.

\begin{minted}{java}
Scanner s = new Scanner(System.in);
double income, tax, numChildren, credit;

System.out.println("Please enter your Adjusted Gross Income: ");
income = s.nextDouble();

System.out.println("How many children do you have?");
numChildren = s.nextDouble();

if(income < 0 || numChildren < 0) {
  System.out.println("Invalid inputs");   
  System.exit(1);
}
\end{minted}

Next, we can code a series of if-else-if statements for the income range.  By
placing the ranges in increasing order, we only need to check the upper bounds
just as in the original example.

\begin{minted}{java}
  if(income <= 18150) {
    baseTax = income * .10;
  } else if(income <= 73800) {
    baseTax = 1815 + (income - 18150) * .15;
  } else if(income <= 148850) {
  ...  
  } else {
    baseTax = 127962.50 + (income - 457600) * .396;
  }
\end{minted}

Next we compute the child tax credit, taking care that it does
not exceed \$3,000.  A conditional based on the number of children
should suffice as at this point in the program we already know it is
zero or greater.

\begin{minted}{java}
  if(numChildren <= 3) {
    credit = numChildren * 1000;
  } else {
    credit = 3000;
  }
\end{minted}

Finally, we need to ensure that the credit does not exceed the total tax
liability (the credit is non-refundable, so if the credit is greater, the tax
should only be zero, not negative).  

\begin{minted}{java}
  if(baseTax - credit >= 0) {
    totalTax = baseTax - credit;
  } else {
    totalTax = 0;
  }
\end{minted}

The full program is presented in Code Sample \ref{code:java:taxProgram}.

\begin{listing}[h]
\begin{minted}[fontsize=\footnotesize]{java}
import java.util.Scanner;

public class Taxes {

  public static void main(String args[]) {

    Scanner s = new Scanner(System.in);
    double income, baseTax, totalTax, numChildren, credit;

    System.out.println("Please enter your Adjusted Gross Income: ");
    income = s.nextDouble();

    System.out.println("How many children do you have?");
    numChildren = s.nextDouble();

    if(income < 0 || numChildren < 0) {
      System.out.println("Invalid inputs");   
      System.exit(1);
    }

    if(income <= 18150) {
      baseTax = income * .10;
    } else if(income <= 73800) {
      baseTax = 1815 + (income  -18150) * .15;
    } else if(income <= 148850) {
      baseTax = 10162.50 + (income - 73800) * .25;
    } else if(income <= 225850) {
      baseTax = 28925.00 + (income - 148850) * .28;
    } else if(income <= 405100) {
      baseTax = 50765.00 + (income - 225850) * .33;
    } else if(income <= 457600) {
      baseTax = 109587.50 + (income - 405100) * .35;
    } else {
      baseTax = 127962.50 + (income - 457600) * .396;
    }

    if(numChildren <= 3) {
      credit = numChildren * 1000;
    } else {
      credit = 3000;
    }

    if(baseTax - credit >= 0) {
      totalTax = baseTax - credit;
    } else {
      totalTax = 0;
    }

    System.out.printf("AGI:           $%10.2f\n", income);
    System.out.printf("Tax:           $%10.2f\n", baseTax);
    System.out.printf("Credit:        $%10.2f\n", credit);
    System.out.printf("Tax Liability: $%10.2f\n", totalTax);

  }

}
\end{minted}
\caption{Tax Program in Java}
\label{code:java:taxProgram}
\end{listing}

\subsection{Quadratic Roots Revisited}

Let's return to the quadratic roots program we previously designed that uses
the quadratic equation to compute the roots of a quadratic polynomial by reading
coefficients $a, b, c$ in from the user.  One of the problems we had previously 
identified is if the user enters ``bad'' input: if $a = 0$, we would end up dividing
by zero; if $b^2-4ac < 0$ then we would have complex roots.  With conditionals, 
we can now check for these issues and exit with an error message.  

Another potential case we might want to handle differently is when there is only
one distinct root ($b^2 - 4ac = 0$).  In that case, the quadratic formula simplifies 
to $\frac{-b}{2a}$ and we can print a different, more specific message to the user.
The full program can be found in Code Sample \ref{code:java:quadraticRootsProgramWithErrorChecking}.

\begin{listing}[h]
\begin{minted}{java}
/**
 * This program computes the roots to a quadratic equation
 * using the quadratic formula.
 */
public class Roots {

  public static void main(String args[]) {
    double a, b, c, root1, root2;

    if(args.length != 3) {
      System.err.println("Usage: a b c\n");
      System.exit(1);
    }

    a = Double.parseDouble(args[0]);
    b = Double.parseDouble(args[1]);
    c = Double.parseDouble(args[2]);
    
    if(a == 0) {
      System.err.println("Error: a cannot be zero");
      System.exit(1);
    } else if(b*b < 4*a*c) {
      System.err.println("Error: cannot handle complex roots\n");
      System.exit(1);
    } else if(b*b == 4*a*c) {
      root1 = -b / (2*a);
      System.out.printf("Only one distinct root: %f\n", root1);
    } else {
      root1 = (-b + Math.sqrt(b*b - 4*a*c) ) / (2*a);
      root2 = (-b - Math.sqrt(b*b - 4*a*c) ) / (2*a);
    
      System.out.printf("The roots of %fx^2 + %fx + %f are: \n", 
      	a, b, c);
      System.out.printf("  root1 = %f\n", root1);
      System.out.printf("  root2 = %f\n", root2);
    }
  }

}
\end{minted}
\caption{Quadratic Roots Program in Java With Error Checking}
\label{code:java:quadraticRootsProgramWithErrorChecking}
\end{listing}
